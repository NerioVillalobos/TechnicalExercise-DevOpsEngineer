# üåê TechnicalExercise-DevOpsEngineer  
**Design and implement a minimal yet complete workflow for deploying a microservice**

---

## üß≠ Language Menu

| Language | Section |
|-----------|----------|
| üá¨üáß [English Version](#english-version) |
| üá™üá∏ [Versi√≥n en Espa√±ol](#versi√≥n-en-espa√±ol) |

---

# üá¨üáß English Version

## How the solution was built

To implement the microservice, the solution was based on **Java Spring Boot**, as it is one of the most mature and widely used frameworks in enterprise environments.  
It provides strong automation, reliability, scalability, monitoring, and security capabilities.

The following dependencies were used:
1. **Spring Boot Starter Web**  
2. **Spring Boot Starter Test**  
3. **Spring Boot Actuator**

With these dependencies, the project implements:
1. The `/health` endpoint for health checks.  
2. Unit test execution.  
3. Metric exposure through `GET /actuator/metrics` and `GET /actuator/health`.  
4. Logback configuration to output JSON logs for ELK or CloudWatch integration.  
5. A `/actuator/prometheus` endpoint to integrate easily with Prometheus and Grafana.

---

## APP Specifications

The app responds with a simple `OK` message when visiting `/health` on port 8080 of the localhost.

```java
public class HealthController {

    @GetMapping("/health")
    public String health() {
        return "OK";
    }
}
```

It is also configured to return health status and additional diagnostic information through Actuator endpoints.

---

## CI/CD Methodology and Automation

The branch model follows a **standard Git workflow**, maintaining a clear versioning and responsibility structure:

- **master** ‚Äì production branch.  
- **sprints** ‚Äì development coordination branch.  
- **features** ‚Äì individual branches for feature development.  
- **hotfix** ‚Äì urgent fixes for production environments.

![Branch Model](imagen/brach-model.png "Branch Model")

Two YAML workflow files were created under `.github/workflows/` to automate validation and deployment steps:

### **PushOn.yml**
Triggered automatically when performing a `git push` to `feature/*` or `hotfix/*` branches.  
This pipeline compiles and runs unit tests (`mvn clean verify`).  
If the tests pass successfully, the push is accepted; otherwise, the workflow fails and marks the commit in GitHub.

---

## Dockerization

A `Dockerfile` is included in the project root. It builds a Docker image from the JAR file generated by Maven.

Steps to build and run locally:
1. `mvn clean package`  
2. `docker build -t simplemicroservice:local .`  
3. `docker run -p 8080:8080 simplemicroservice:local`

This allows the microservice to run in a containerized environment.

---

## Execution Environment (Production)

**Kubernetes** was selected as the runtime platform because:
- It supports multiple Java-based microservices.
- It allows native health checks using `/actuator/health`.
- It integrates easily with CI/CD pipelines and declarative deployments.
- It supports centralized observability (Prometheus, ELK).

---

### **CompletePR.yml**
Triggered when creating a Pull Request to the `sprint` branch.  
This workflow performs a full integration process including:
- **Code checkout**  
- **Compilation and unit tests** (`mvn clean package`)  
- **Docker image build** (`docker build`)  
- **Kubernetes manifests application** to a test namespace (`kubectl apply`)

---

### General Pipeline Flow

1. **Developer / Git**
   - Developer commits changes.
   - Executes `git push` to a `feature/...` or `hotfix/...` branch.

2. **GitHub Actions ‚Äì PushOn.yml**
   - Triggers lightweight workflow.
   - Runs `./mvnw clean verify`.
   - If successful, the code is accepted.
   - If failed, the push is rejected.

3. **Pull Request ‚Üí `feature` or `hotfix`**
   - A Pull Request is created from `feature/...` or `hotfix/...` to `main`.

4. **GitHub Actions ‚Äì CompletePR.yml**
   - Runs the full build pipeline.
   - Performs compile, test, Docker build, and simulated Kubernetes deployment.

5. **Kubernetes (Test Environment)**
   - The `Deployment` updates the image.
   - The `Pod` is recreated with the new Spring Boot container.
   - The `Service` exposes the Pod inside the cluster.
   - The `Ingress` exposes it externally via HTTP.
   - Prometheus and ELK collect metrics and structured logs.

This workflow continuously validates code quality, ensures traceability, and automates deployments to controlled test environments.

6. **Deployments to higher environments**
   - Performed through a dedicated job, selecting the tag/version from the PR merged into `main`.

Together, both pipelines (**PushOn.yml** and **CompletePR.yml**) ensure that:
- Only successful commits are integrated.  
- Pull Requests create reproducible builds verified in Kubernetes.  
- Code quality and stability are maintained before reaching production.

---

### Optional: Registry Publishing
The exercise‚Äôs step 4 requests image publishing to a registry.  
`CompletePR.yml` is prepared to support this but intentionally disabled for evaluation purposes.  
You can enable it by adding `docker/login-action` and `docker push` steps and configuring registry secrets.

---

## Observability

- **Structured logging** via Logback (JSON format) for centralized aggregation (ELK / CloudWatch).  
- **Metrics exposed** through Spring Boot Actuator:  
  - `/actuator/health`  
  - `/actuator/metrics`  
  - `/actuator/prometheus`

This allows integration with **Prometheus** and **Grafana** for monitoring and visualization.

---

## Solution Diagram

![Solution diagram](imagen/TechnicalExercise-Solution.png "Solution diagram")

---

## Vulnerability Management

- **Code dependencies:** use `mvn versions:display-dependency-updates` and/or GitHub Dependabot integration to detect vulnerable libraries.  
- **Container images:** scan the generated image with **Trivy** or **Grype** during CI (optional step in `CompletePR.yml`).  
- **Base OS layers:** keep the base image (`eclipse-temurin:17-jre-alpine` or similar) updated and version-pinned.  
- **Vulnerability handling:** if a critical issue is found, update the code, rebuild the image, and redeploy to keep the service secure.

---

## Key Technical Decisions

1. **Framework:** Spring Boot instead of Micronaut for maturity and enterprise adoption.  
   Micronaut can be used in specific scenarios requiring more speed and efficiency.  
2. **Containers:** Docker chosen for packaging portability.  
3. **Orchestrator:** Kubernetes chosen for its built-in health checks, scalability, and observability.  
4. **CI/CD:** GitHub Actions split into two workflows (push validation and full PR pipeline) to separate concerns.  
5. **Observability:** Actuator and JSON logs used for Prometheus / ELK integration.

---

# üá™üá∏ Versi√≥n en Espa√±ol

# TechnicalExercise-DevOpsEngineer
Design and implement a minimal yet complete workflow for deploying a microservice


## Como se realizo la solucion

Para realizar el microservicio se decidio escoger una solucion basada en Java Spring Boot, debido a que es el standard para implementaciones empresariales y por la robustes en automatizacion del despliegue, fiabilidad, escalabilidad, monitoreo y seguridad.

Se decidio utilizaran las siguientes dependencias:
1. Spring Boot Starter Web
2. Spring Boot Starter Test
3. Spring Boot Actuator

Con estas dependencia vamos a poder lograr implementar lo requerido la respuesta de:
1. implementacion de endpoint `/health`
2. ejecucion de pruebas unitarias
3. posibilidad de capturar las metricas `GET /actuator/metrics` y `GET /actuator/health`
4. se crea archivo logback para que emita un json por defecto y se pueda capturar con ELK o CloudWatch
5. se le crea una capa de metricas `/actuator/prometheus` esto permite integrarlo con Prometheus o Grafana

## Especificaciones de la APP

Se configura para que solo responda un `OK` al visitar /health sobre el puerto 8080 del localhost
```Bash
public class HealthController {

    @GetMapping("/health")
    public String health() {
        return "OK";
    }
}
```

Se configura tambien para que devuelva un status para su monitoreo y una ruta que devuelven los valores requeridos para obtener mas informacion del microservicio

## Metodolog√≠a y Automatizaci√≥n CI/CD

El modelo de ramas (branch model) se basa en un flujo Git est√°ndar, manteniendo una estructura clara de versiones y responsabilidades:

- **master** : rama principal de producci√≥n.
- **sprints** : rama de seguimiento de desarrollo en equipo.
- **features** : ramas individuales para desarrollo de historias de usuario.
- **hotfix** : ramas dedicadas a correcciones urgentes en ambientes productivos.

![Branch Model](imagen/brach-model.png "Branch Model")

Fueron creados dos archivos YAML dentro del directorio de workflows de GitHub Actions que automatizan las validaciones y despliegues:

- **PushOn.yml** :  
  Se ejecuta autom√°ticamente al realizar un `git push` hacia ramas `feature/*` o `hotfix/*`.  
  Este pipeline realiza compilaci√≥n y ejecuci√≥n de pruebas unitarias (`mvn clean verify`).  
  Si las pruebas pasan exitosamente, el push se completa; en caso contrario, el flujo se detiene marcando el error en GitHub.

## Dockerizaci√≥n
Se incluye un `Dockerfile` en la ra√≠z del proyecto que construye una imagen a partir del JAR generado por Maven:

1. `mvn clean package`
2. `docker build -t simplemicroservice:local .`
3. `docker run -p 8080:8080 simplemicroservice:local`

Esto permite ejecutar el microservicio en un contenedor.

## Entorno de ejecuci√≥n (Producci√≥n)
Se eligi√≥ **Kubernetes** como plataforma de ejecuci√≥n porque:
- soporta m√∫ltiples microservicios Java como los descritos en el enunciado,
- permite health checks nativos usando `/actuator/health`,
- se integra f√°cilmente con CI/CD y despliegues declarativos,
- facilita observabilidad centralizada (Prometheus, ELK).


- **CompletePR.yml** :  
  Se ejecuta al crear un Pull Request hacia la rama `de sprint`.  
  Este pipeline realiza un proceso de integraci√≥n completo que incluye:
  - **Checkout** del c√≥digo.
  - **Compilaci√≥n y pruebas unitarias** (`mvn clean package`).
  - **Construcci√≥n de la imagen Docker** (`docker build`).
  - **Aplicaci√≥n de manifiestos Kubernetes** en un *namespace* de prueba (`kubectl apply`).

### Flujo general del pipeline

1. **Developer / Git**
   - El desarrollador realiza cambios en el proyecto.
   - Ejecuta `git push` hacia una rama `feature/...` o `hotfix/...`.

2. **GitHub Actions ‚Äì PushOn.yml**
   - Se dispara el workflow ligero.
   - Ejecuta `./mvnw clean verify`.
   - Si pasa: el c√≥digo se integra en el repositorio.
   - Si falla: el push queda bloqueado con un check rojo.

3. **Pull Request ‚Üí `feature` y `hotfix`**
   - Se crea un Pull Request desde `feature/...` o `hotfix/...` hacia `main`.

4. **GitHub Actions ‚Äì CompletePR.yml**
   - Se dispara el workflow completo.
   - Realiza compilaci√≥n, test, construcci√≥n de la imagen Docker y (si est√° configurado) despliegue al ambiente de prueba.

5. **Kubernetes (ambiente de prueba)**
   - El `Deployment` se actualiza con la nueva imagen.
   - Se crea o actualiza el `Pod` que contiene el microservicio Spring Boot.
   - El `Service` interno de Kubernetes expone el pod dentro del cluster.
   - El `Ingress` permite el acceso HTTP externo al microservicio.
   - Prometheus y ELK recolectan m√©tricas y logs estructurados para observabilidad.

Este flujo permite validar continuamente la calidad del c√≥digo, mantener la trazabilidad entre ramas y asegurar la entrega automatizada hacia entornos controlados de prueba.

6. **Despliegues a ambientes altos**
  - Se realizan a partir de un JOB donde se selecciona el tag y version incorporado por un Pull Request en la rama `main`

  Ambos pipelines en conjunto (PushOn.yml y CompletePR.yml) aseguran que:
  - Los commits solo se integran si superan las pruebas.
  - Los Pull Requests generan builds reproducibles y verificables en Kubernetes.
  - La calidad y estabilidad del c√≥digo se mantienen antes de llegar a producci√≥n.

### Publicaci√≥n en registry (opcional)
El punto 4 del ejercicio solicita publicar la imagen en un registry. El workflow `CompletePR.yml` est√° preparado para incluir pero no se coloco para permitir la ejecuci√≥n en un entorno de evaluaci√≥n sin credenciales. simplemente se deben agregar las opciones en las secciones de `docker/login-action` y `docker push` y configurar el secret del registry.

## Observabilidad
- Logging estructurado mediante Logback (formato JSON) para centralizaci√≥n (ELK / CloudWatch).
- M√©tricas expuestas v√≠a Spring Boot Actuator:
  - `/actuator/health`
  - `/actuator/metrics`
  - `/actuator/prometheus`
Esto permite integrarse con Prometheus y Grafana.


## Diagrama de la solucion

![Solution diagram](imagen/TechnicalExercise-Solution.png "Solution diagram")


## Gesti√≥n de vulnerabilidades

- **Dependencias de c√≥digo**: usar `mvn versions:display-dependency-updates` y/o integraci√≥n con GitHub Dependabot para detectar librer√≠as vulnerables.
- **Im√°genes de contenedor**: escanear la imagen generada con una herramienta como Trivy o Grype en la etapa de CI (paso opcional que se puede agregar en `CompletePR.yml`).
- **Capas del SO base**: mantener la imagen base actualizada (`eclipse-temurin:17-jre-alpine` o similar) y fijar versiones para evitar inconvenientes por versiones.
- **Manejo de Vulnerabilidades**: si se detecta una vulnerabilidad grave, se actualiza el c√≥digo, se recompila la imagen y se vuelve a desplegar para asegurar que el servicio no quede expuesto.

## Decisiones t√©cnicas clave
1. **Framework**: Spring Boot en lugar de Micronaut, por madurez y est√°ndar enterprise, se puede trabajar con Micronaut en situaciones muy especificas donde se requiera mas vlocidad y mas eficiencia en los recursos.
2. **Contenedores**: Docker como formato de empaquetado para permitir despliegue en cualquier plataforma.
3. **Orquestador**: Kubernetes elegido por soporte de health checks, escalabilidad y observabilidad integrada.
4. **CI/CD**: GitHub Actions dividido en dos workflows (validaci√≥n de push y pipeline completo de PR) para separar calidad de integraci√≥n.
5. **Observabilidad**: uso de Actuator y logs JSON para integraci√≥n con Prometheus / ELK.
